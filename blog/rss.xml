<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Catlang Blog</title>
        <link>https://aszecsei.github.io/catlang/blog</link>
        <description>Catlang Blog</description>
        <lastBuildDate>Sun, 16 Dec 2018 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Roadmap]]></title>
            <link>https://aszecsei.github.io/catlang/blog/2018/12/16/roadmap</link>
            <guid>/2018/12/16/roadmap</guid>
            <pubDate>Sun, 16 Dec 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[We're fast approaching the release of version 0.1! The lexer and parser are mostly complete, barring a few additional features. In this post, I'll talk about how far the compiler has come - and where continued efforts are going.]]></description>
            <content:encoded><![CDATA[<p>We're fast approaching the release of version 0.1! The lexer and parser are mostly complete, barring a few additional features. In this post, I'll talk about how far the compiler has come - and where continued efforts are going.</p><h1>Progress</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="from-go-to-rust">From Go To Rust<a class="hash-link" href="#from-go-to-rust" title="Direct link to heading">​</a></h2><p>After a brief false start in Go, catlang transitioned to use Rust. I put some effort into creating a small extension for Visual Studio Code to perform basic syntax highlighting. This helped when writing example code, as well as when ensuring that there wasn't much gap between the language grammar (written in EBNF) and the language specification detailed in this documentation.</p><p>I also transitioned the language documentation from using LaTeX to using docusaurus; this has the benefit of automatic updates to GitHub pages, enabling new users to more easily learn the language while maintaining better formatting than I achieved in LaTeX.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-rust-conversion">The Rust Conversion<a class="hash-link" href="#the-rust-conversion" title="Direct link to heading">​</a></h2><p>At first, I tried to convert line-by-line from my Go code to Rust. This ended up frustrating me a bit - occasional issues with the borrow checker caused me to have to re-consider data ownership. Error handling, in particular, became much more complex. This led to a secondary overhaul, late in development, when I worked to add further functionality for error handling. To help with this, I was able to adapt some ideas from the Rust compiler.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-lexer">The Lexer<a class="hash-link" href="#the-lexer" title="Direct link to heading">​</a></h2><p>Most of the lexer was straightforward, and didn't require much alteration. Perhaps the only complex aspect was the few 3-character tokens (such as <code>&gt;&gt;=</code> and <code>&amp;&amp;=</code>) and even this was easily resolved with nested conditionals.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-parser">The Parser<a class="hash-link" href="#the-parser" title="Direct link to heading">​</a></h2><p>The parser was more complex - the EBNF grammar I'd written turned out at several points to not actually reflect the language documentation I'd been writing. There was something of a back-and-forth between the grammar and the parser, as I realized that aspects needed to be fixed. In addition, a rewrite was necessary partway through writing the expression parser, as I realized that all of the parsing I was doing was right-associative, and several operators (such as subtraction) needed to be left-associative instead.</p><p>In addition, figuring out how to perform error handling in Rust caused a few issues. I wanted to be able to display problematic spans of code, and so needed both a <code>peekable</code> iterator (for the lexer) and a regular <code>String</code> for the error reporting. Because a structure in Rust cannot hold a reference to one of its own members, I had to set up these in separate parts of the code, and pass them through as separate arguments.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="code-generation">Code Generation<a class="hash-link" href="#code-generation" title="Direct link to heading">​</a></h2><p>I ran into a few issues with building LLVM instructions - the <code>llvm-sys</code> package ran into linker errors on Windows, and so I had to pivot to generating C code instead. This has the beginning of functionality.</p><p>The code generation features don't quite compile yet, and so are behind a separate <code>c-codegen</code> branch.</p><h1>Future Work</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-lexer-1">The Lexer<a class="hash-link" href="#the-lexer-1" title="Direct link to heading">​</a></h2><p>The lexer still needs some functionality for dealing with floating point numbers, and numbers with non-10 bases. Aside from this, the lexer is mostly complete.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-parser-1">The Parser<a class="hash-link" href="#the-parser-1" title="Direct link to heading">​</a></h2><p>A few statements still need implementation efforts - loops, branching statements, inner blocks and imports, and so on.</p><p>In addition, the created parse tree still needs to be knitted and type-checked.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="code-generation-1">Code Generation<a class="hash-link" href="#code-generation-1" title="Direct link to heading">​</a></h2><p>While the C code generation works as a stopgap measure, determining the root cause of the <code>llvm-sys</code> linker errors would likely be a better way to proceed. In addition, no optimization features are currently included.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello, World!]]></title>
            <link>https://aszecsei.github.io/catlang/blog/2018/10/17/hello-world</link>
            <guid>/2018/10/17/hello-world</guid>
            <pubDate>Wed, 17 Oct 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[While much of Catlang is progressing nicely (the grammar is almost entirely fleshed out!) there have been a few setbacks. Namely, we're switching from Go to Rust - which is a net positive, but requires re-writing some of the existing code.]]></description>
            <content:encoded><![CDATA[<p>While much of Catlang is progressing nicely (the grammar is almost entirely fleshed out!) there have been a few setbacks. Namely, we're switching from Go to Rust - which is a net positive, but requires re-writing some of the existing code.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-switch">Why Switch?<a class="hash-link" href="#why-switch" title="Direct link to heading">​</a></h2><p>This mostly has to do with the AST. Go has some strange notions with regards to inheritance - namely, that interfaces are used exclusively. So in order to create a type of <code>Declaration</code>, we have to construct an interface <code>Declaration</code> which requires its members to implement a function <code>declaration()</code>; then all "subclasses" of <code>Declaration</code> just implement that empty function.</p><p>Not optimal, and as we progress further into the parser and IR, these shortcomings are going to become more and more of a problem. So we're cutting the problem off at the pass and using Rust; it has the features of Go that were very helpful (package management, unicode support) and keeps a more traditional, useful inheritance model.</p>]]></content:encoded>
        </item>
    </channel>
</rss>