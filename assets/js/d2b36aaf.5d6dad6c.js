"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[852],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>m});var i=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var p=i.createContext({}),l=function(n){var e=i.useContext(p),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=l(n.components);return i.createElement(p.Provider,{value:e},n.children)},d={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},u=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,p=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),u=l(t),m=r,f=u["".concat(p,".").concat(m)]||u[m]||d[m]||a;return t?i.createElement(f,o(o({ref:e},c),{},{components:t})):i.createElement(f,o({ref:e},c))}));function m(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var p in e)hasOwnProperty.call(e,p)&&(s[p]=e[p]);s.originalType=n,s.mdxType="string"==typeof n?n:r,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3760:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=t(7462),r=t(3366),a=(t(7294),t(3905)),o=["components"],s={id:"grammar",title:"Grammar",sidebar_label:"Grammar"},p=void 0,l={unversionedId:"grammar",id:"grammar",title:"Grammar",description:"EBNF",source:"@site/docs/grammar.md",sourceDirName:".",slug:"/grammar",permalink:"/catlang/docs/grammar",draft:!1,editUrl:"https://github.com/aszecsei/catlang/edit/master/website/docs/grammar.md",tags:[],version:"current",frontMatter:{id:"grammar",title:"Grammar",sidebar_label:"Grammar"},sidebar:"docs",previous:{title:"Build System",permalink:"/catlang/docs/build-system"}},c={},d=[{value:"EBNF",id:"ebnf",level:2},{value:"TODO",id:"todo",level:2}],u={toc:d};function m(n){var e=n.components,t=(0,r.Z)(n,o);return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"ebnf"},"EBNF"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ebnf"},'lexeme\n    = identifier\n    | reserved word\n    | number\n    | string literal\n    | character literal\n    | byte literal\n    | byte string literal\n    | punctuation\n    | end of file\n    ;\n\nidentifier\n    = letter , { letter | digit | "_" }\n    ;\n\nnumber\n    = decimal integer\n    | decimal float\n    | "0x" , hexadecimal integer\n    | "0o" , octal integer\n    | "0b" , binary integer\n    ;\n\ndecimal integer\n    = [ "+" | "-" ] , digit , { digit } [ integer type ]\n    ;\n\ndecimal float\n    = [ "+" | "-" ] , digit , { digit } , floating point type\n    | [ "+" | "-" ] , digit , { digit } , "." , { digit } [ floating point type ]\n    | [ "+" | "-" ] , "." , digit , { digit } [ floating point type ]\n    ;\n\nhexadecimal integer\n    = hexadecimal digit , { hexadecimal digit }\n    ;\n\noctal integer\n    = octal digit , { octal digit }\n    ;\n\nbinary number\n    = binary digit , { binary digit }\n    ;\n\nstring literal\n    = \'"\' , { string character } , \'"\'\n    ;\n\ncharacter literal\n    = "\'" , string character , "\'"\n    ;\n\nbyte literal\n    = "b\'" , byte character , "\'"\n    ;\n\nbyte string literal\n    = \'b"\' , { byte character } , \'"\'\n    ;\n\nstring character\n    = ? utf-8 character ?\n    | quote escape\n    | ascii escape\n    | unicode escape\n    ;\n\nbyte character\n    = ? ascii character ?\n    | quote escape\n    | byte escape\n    ;\n\nascii escape\n    = "\\x" , 2*( hexadecimal digit ) (* 7-bit character code (exactly 2 digits, up to 0x7F) *)\n    | "\\n" (* newline *)\n    | "\\r" (* carriage return *)\n    | "\\t" (* tab *)\n    | "\\\\" (* backslash *)\n    | "\\0" (* null *)\n    ;\n\nbyte escape\n    = "\\x" , 2*( hexadecimal digit ) (* 8-bit character code (exactly two digits) *)\n    | "\\n"\n    | "\\r"\n    | "\\t"\n    | "\\\\"\n    | "\\0"\n    ;\n\nunicode escape\n    = "\\u{" , 6*( hexadecimal digit ) , "}" (* 24-bit Unicode character code (up to 6 digits) *)\n    ;\n\nquote escape\n    = "\\\'"\n    | "\\""\n    ;\n\npunctuation\n    = "("\n    | ")"\n    | "{"\n    | "}"\n    | "#["\n    | "["\n    | "]"\n    | ":"\n    | "::"\n    | ";"\n    | ","\n    | "@"\n    | "+"\n    | "+="\n    | "++"\n    | "-"\n    | "-="\n    | "--"\n    | "*"\n    | "*="\n    | "/"\n    | "/="\n    | "%"\n    | "%="\n    | "="\n    | "&"\n    | "&="\n    | "&&"\n    | "&&="\n    | "|"\n    | "|="\n    | "||"\n    | "||="\n    | "!"\n    | "~"\n    | "^"\n    | "^="\n    | "<<"\n    | ">>"\n    | "=="\n    | "!="\n    | "<"\n    | ">"\n    | "<="\n    | ">="\n    | "->"\n    | "?"\n    | "??"\n    | "."\n    | ".."\n    | "..."\n    ;\n\nreserved words\n    = "any"\n    | "let"\n    | "const"\n    | "new"\n    | "delete"\n    | "typeof"\n    | "is"\n    | "as"\n    | "in"\n    | "function"\n    | "return"\n    | "struct"\n    | "type"\n    | "enum"\n    | "SOA"\n    | "owned"\n    | "import"\n    | "export"\n    | "from"\n    | "for"\n    | "while"\n    | "do"\n    | "loop"\n    | "if"\n    | "else"\n    | "break"\n    | "continue"\n    | "this"\n    ;\n\ncatlang file\n    = catlang module\n    | catlang script\n    ;\n\ncatlang module\n    = { [ import | export | ( { attribute } , declaration ) } , end of file\n    ;\n\ncatlang script\n    = { { attribute } , declaration } , end of file\n    ;\n\nattribute\n    = "#[" , attribute list , "]"\n    ;\n\nattribute list\n    = attribute element , { "," , attribute element }\n    ;\n\nattribute element\n    = identifier , [ "(" , [ attribute parameter list ] , ")" ]\n    ;\n\nattribute parameter list\n    = attribute parameter , { "," , attribute parameter }\n    ;\n\nattribute parameter\n    = expression\n    ;\n\nimport\n    = "import" , import list , "from" , string literal\n    ;\n\nexport\n    = { attribute } , "export" , declaration (* export declaration *)\n    | "export" , identifier , [ "as" , identifier ] (* export statement *)\n    | "export" , import list , "from" , string literal (* re-export *)\n    ;\n\nimport list\n    = "{" , import identifier , { "," , import identifier } , "}"\n    | "*" , "as", identifier\n    ;\n\nimport identifier\n    = identifier , [ "as" , identifier ]\n    ;\n\nblock\n    = "{" { declaration | statement | import } "}"\n    ;\n\ndeclaration\n    = constant declaration\n    | type declaration\n    | variable declaration\n    | function declaration\n    | struct declaration\n    | enum declaration\n    ;\n\nconstant declaration\n    = "const" , identifier , [ ":" , type expression ] , "=" , expression\n    ;\n\ntype declaration\n    = "type" , identifier , "=" , type expression\n    ;\n\nvariable declaration\n    = "let" , identifier , [ ":" , type expression ] , [ "=" , expression ]\n    ;\n\nfunction declaration\n    = "function" , scoped identifier , [ generic parameter list ] , "(" , [ formal parameter list ] , ")" , [ "->" , [ type expression ] ] , block\n    ;\n\nformal parameter list\n    = "this" , { "," , parameter }\n    | parameter , { "," , parameter }\n    ;\n\nparameter\n    = identifier , ":" , type expression\n    ;\n\nstruct declaration\n    = "struct" , identifier , [ generic parameter list ] , "{" , struct parameter list , "}"\n    ;\n\nstruct parameter list\n    = { struct parameter , [ ";" ] }\n    ;\n\nstruct parameter\n    = identifier , ":" , [ "owned" , "*" ] , type expression , [ "=" , expression ]\n    ;\n\ngeneric parameter list\n    = "<" , identifier , { "," , identifier } , ">"\n    ;\n\nenum declaration\n    = "enum" , identifier , [ ":" , enum representation ] , "{" , [ enum value list ] , "}"\n    ;\n\nenum value list\n    = { enum value , "," } , enum value , [ "," ]\n    ;\n\nenum value\n    = { identifier , [ "=" , expression ] }\n    ;\n\nenum representation\n    = "s8"\n    | "u8"\n    | "s16"\n    | "u16"\n    | "s32"\n    | "u32"\n    | "s64"\n    | "u64"\n    ;\n\nstatement\n    = block\n    | if\n    | loop\n    | jump\n    | delete\n    | expression\n    ;\n\nif\n    = "if" , "(" , expression , ")" , statement , [ "else" , statement ]\n    ;\n\nloop\n    = for\n    | while\n    | do while\n    | infinite loop\n    ;\n\nfor\n    = "for" , "(" , identifier , "in", expression , ")" , statement\n    ;\n\nwhile\n    = "while" , "(", condition , ")" , statement\n    ;\n\ndo while\n    = "do" , statement , "while" , "(" , condition , ")"\n    ;\n\ninfinite loop\n    = "loop" , statement\n    ;\n\njump\n    = "break"\n    | "continue"\n    | "return" , [ expression ]\n    ;\n\ndelete\n    = "delete" , scoped identifier\n    ;\n\ntype expression\n    = type union\n    | unary type expression\n    ;\n\ntype union\n    = unary type expression , "|" , type expression\n    ;\n\nunary type expression\n    = pointer to\n    | sized array\n    | unsized array\n    | const type\n    | volatile type\n    | optional type\n    | simple type expression\n    ;\n\npointer to\n    = "*" , unary type expression\n    ;\nsized array\n    = "[" , "]" , unary type expression\n    ;\nunsized array\n    = "[" , ".." , "]" , unary type expression\n    ;\nconst type\n    = "const" , unary type expression\n    ;\nvolatile type\n    = "volatile" , unary type expression\n    ;\noptional type\n    = "?" , unary type expression\n    ;\n\nsimple type expression\n    = typeof expression\n    | named type\n    | primitive type\n    | "(" type expression ")"\n    | "any"\n    ;\n\ntypeof expression\n    = "typeof" , expression\n    ;\nnamed type\n    = identifier { "::" , identifier } [ generic type list ] (* scoped types *)\n    ;\nprimitive type\n    = integer type\n    | boolean type\n    | floating point type\n    | unvalued type\n    | "type"\n    ;\n\ninteger type\n    = "s8"\n    | "u8"\n    | "s16"\n    | "u16"\n    | "s32"\n    | "u32"\n    | "s64"\n    | "u64"\n    | "char"\n    | "short"\n    | "int"\n    | "long"\n    | "c_short"\n    | "c_ushort"\n    | "c_int"\n    | "c_uint"\n    | "c_long"\n    | "c_ulong"\n    | "c_longlong"\n    | "c_ulonglong"\n    | "c_longdouble"\n    ;\n\nboolean type\n    = "bool"\n    ;\n\nfloating point type\n    = "f32"\n    | "f64"\n    | "float"\n    | "double"\n    ;\n\nunvalued type\n    = "null"\n    | "noreturn"\n    | "c_void"\n    ;\n\ngeneric type list\n    = "<" , type expression , { "," , type expression } >\n    ;\n\nexpression\n    = assignment expression\n    ;\n\nassignment expression (* right-associative *)\n    = scoped identifier , assignment operator , assignment expression\n    | ternary expression\n    ;\nassignment operator\n    = "="\n    | "+="\n    | "-="\n    | "*="\n    | "/="\n    | "%="\n    | "&="\n    | "&&="\n    | "|="\n    | "||="\n    | "^="\n    | "<<="\n    | ">>="\n    | "??="\n    ;\n\nternary expression (* right-associative *)\n    = or expression , [ "?" , expression , ":" , expression ]\n    ;\n\nor expression (* left-associative *)\n    = and expression , { "||" , and expression }\n    ;\n\nand expression (* left-associative *)\n    = equality expression , { "&&" , equality expression }\n    ;\n\nequality expression (* left-associative *)\n    = type test expression , { equality operator , type test expression }\n    ;\nequality operator\n    = "=="\n    | "!="\n    ;\n\ntype test expression (* left-associative *)\n    = comparison expression , [ "is" , type expression ]\n    ;\n\ncomparison expression (* left-associative *)\n    = bitwise or expression , { comparison operator , bitwise or expression }\n    ;\ncomparison operator\n    = "<"\n    | "<="\n    | ">"\n    | ">="\n    | "in"\n    ;\n\nbitwise or expression (* left-associative *)\n    = bitwise xor expression , { "|" , bitwise xor expression }\n    ;\n\nbitwise xor expression (* left-associative *)\n    = bitwise and expression , { "^" , bitwise and expression }\n    ;\n\nbitwise and expression (* left-associative *)\n    = bitshift expression , { "&" , bitshift expression }\n    ;\n\nbitshift expression (* left-associative *)\n    = range expression , { bitshift operator , range expression }\n    ;\nbitshift operator\n    = ">>"\n    | "<<"\n    ;\n\nrange expression (* left-associative *)\n    = adding expression , { range operator , adding expression }\n    ;\nrange operator\n    = ".."\n    | "..."\n    ;\n\nadding expression (* left-associative *)\n    = term , { adding operator , term }\n    ;\nadding operator\n    = "+"\n    | "-"\n    ;\n\nterm (* left-associative *)\n    = factor , { multiplying operator , factor }\n    ;\nmultiplying operator\n    = "*"\n    | "/"\n    | "%"\n    ;\n\nfactor (* right-associative *)\n    = prefix operator , factor\n    | suffix expression , "as" , ["!"] , factor\n    | suffix expression , "??" , factor\n    | suffix expression\n    ;\nprefix operator\n    = "++"\n    | "--"\n    | "+"\n    | "-"\n    | "!"\n    | "~"\n    | "@"\n    | "*"\n    ;\n\nsuffix expression (* left-associative *)\n    = value , suffix operator\n    | value , [ generic type list ] , "(" , [ expression list ] , ")" (* function call *)\n    | value , [ "?" ] , "[" , [ expression list ] , "]" (* subscript *)\n    | value , { [ "?" ] , "." , suffix expression } (* member access *)\n    | value\n    ;\nsuffix operator\n    = "++"\n    | "--"\n    | "!"\n    ;\n\nvalue\n    = "sizeof" , "(" , type expression , ")"\n    | lambda expression\n    | [ "new" ] , type expression , [ generic type list ] , [ struct initializer ] (* struct allocation via initializer or empty *)\n    | identifier , { "." , identifier } (* module-scoped type *)\n    | number\n    | string literal\n    | character literal\n    | byte literal\n    | byte string literal\n    | reference\n    ;\n\nstruct initializer\n    = "{" , [ { struct initializer param , "," } , struct initializer param , [ "," ] ] "}"\n    ;\nstruct initializer param\n    = identifier , ":" , expression\n    ;\n\nlambda expression\n    = [ generic parameter list ] , "(" , [ formal parameter list ] , ")" , [ "->" , [ type expression ] ] , block\n    ;\n\nscoped identifier\n    = [ type expression , "::" ] , identifier\n    ;\n\nreference\n    = scoped identifier\n    | "this"\n    ;\n')),(0,a.kt)("h2",{id:"todo"},"TODO"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"float exponents (",(0,a.kt)("inlineCode",{parentName:"li"},"0.2e1"),")"),(0,a.kt)("li",{parentName:"ul"},"more enum representations (",(0,a.kt)("inlineCode",{parentName:"li"},"c_int"),"?)"),(0,a.kt)("li",{parentName:"ul"},"let loops have return types via break/continue/etc?"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"suffix expression")," feels poorly-defined")))}m.isMDXComponent=!0}}]);