"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[516],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(a),d=n,g=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return a?r.createElement(g,l(l({ref:t},c),{},{components:a})):r.createElement(g,l({ref:t},c))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,l[1]=i;for(var p=2;p<o;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5336:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>u});var r=a(7462),n=a(3366),o=(a(7294),a(3905)),l=["components"],i={id:"project-structure",title:"Project Structure",sidebar_label:"Project Structure"},s=void 0,p={unversionedId:"project-structure",id:"project-structure",title:"Project Structure",description:"Catlang is comprised of scripts and modules declared in different files. A catlang file containing a top-level import or export is considered a module. A file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).",source:"@site/docs/project-structure.md",sourceDirName:".",slug:"/project-structure",permalink:"/catlang/docs/project-structure",draft:!1,editUrl:"https://github.com/aszecsei/catlang/edit/master/website/docs/project-structure.md",tags:[],version:"current",frontMatter:{id:"project-structure",title:"Project Structure",sidebar_label:"Project Structure"},sidebar:"docs",previous:{title:"Error Handling",permalink:"/catlang/docs/error-handling"},next:{title:"Interop",permalink:"/catlang/docs/interop"}},c={},u=[{value:"Exports",id:"exports",level:2},{value:"Exporting a Declaration",id:"exporting-a-declaration",level:3},{value:"Exporting Statements",id:"exporting-statements",level:3},{value:"Re-Exports",id:"re-exports",level:3},{value:"Imports",id:"imports",level:2},{value:"Importing a Single Export",id:"importing-a-single-export",level:3},{value:"Importing a Module",id:"importing-a-module",level:3},{value:"Path Mapping",id:"path-mapping",level:3},{value:"Importing a Script",id:"importing-a-script",level:2},{value:"Namespaces",id:"namespaces",level:2},{value:"Aliases",id:"aliases",level:3}],m={toc:u};function d(e){var t=e.components,a=(0,n.Z)(e,l);return(0,o.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Catlang is comprised of scripts and modules declared in different files. A catlang file containing a top-level ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," is considered a module. A file without any top-level ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well)."),(0,o.kt)("h2",{id:"exports"},"Exports"),(0,o.kt)("h3",{id:"exporting-a-declaration"},"Exporting a Declaration"),(0,o.kt)("p",null,"Any declaration (such as a variable, function, struct, type alias, or interface) can be exported by prefixing the ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," keyword."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},"export const x = 12;\n")),(0,o.kt)("h3",{id:"exporting-statements"},"Exporting Statements"),(0,o.kt)("p",null,"Export statements are handy when exports need to be renamed, so the preceding example might be written as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},"const x = 12;\nexport { x as myNumber };\n")),(0,o.kt)("h3",{id:"re-exports"},"Re-Exports"),(0,o.kt)("p",null,"Often modules partially expose the featurs of other modules. A re-export does not import the module locally, or introduce a local variable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},'export { fun as myFun } from "module/foo";\n')),(0,o.kt)("h2",{id:"imports"},"Imports"),(0,o.kt)("p",null,"Importing is just as easy as exporting from a module. Importing an exported declaration is done via one of these ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," forms:"),(0,o.kt)("h3",{id:"importing-a-single-export"},"Importing a Single Export"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},'import { x } from "foo";\n')),(0,o.kt)("p",null,"Imports can also be renamed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},'import { x as y } from "foo";\n')),(0,o.kt)("h3",{id:"importing-a-module"},"Importing a Module"),(0,o.kt)("p",null,"You an import an entire module as a struct-like object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},'import * as foo from "module/foo";\n\nfunction main() -> {\n  foo::bar();\n}\n')),(0,o.kt)("h3",{id:"path-mapping"},"Path Mapping"),(0,o.kt)("p",null,"Deeply-nested folders can lead to very verbose imports. Catlang's build system provides path mapping to let you write shortcuts for these long paths. For example, if there are multiple imports from files in ",(0,o.kt)("inlineCode",{parentName:"p"},"src/utils/workers/"),", you can define a path mapping in the package YAML:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="package.yaml"',title:'"package.yaml"'},'paths:\n  - "@workers": src/utils/workers/\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang",metastring:'title="src/example.cat"',title:'"src/example.cat"'},'import { hello } from "@workers/hello.cat"\n')),(0,o.kt)("h2",{id:"importing-a-script"},"Importing a Script"),(0,o.kt)("p",null,'Some files should be accessible across the entire project. Manually importing these commonly-used scripts would be a hassle; thus, Catlang provides global "script" files that are imported automatically in every file. These scripts are specified using the ',(0,o.kt)("inlineCode",{parentName:"p"},"scripts")," field in the project YAML; this style of file inclusion should be similar to that of a C-style linker."),(0,o.kt)("p",null,"Only files that ",(0,o.kt)("em",{parentName:"p"},"are")," scripts (that is, they do not contain any top-level imports or exports) are globally imported. Even if your project YAML declares a non-script file as a script, it will not be registered as such unless it matches this criteria."),(0,o.kt)("p",null,"When using script files, namespaces are recommended to avoid global namespace pollution."),(0,o.kt)("p",null,"Writing libraries using modules is recommended over using scripts, as they lead to fewer unexpected results (such as accidental namespace collisions)."),(0,o.kt)("h2",{id:"namespaces"},"Namespaces"),(0,o.kt)("p",null,"Namespaces can be defined using the ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace")," keyword:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},"namespace Shapes {\n  export struct Triangle {}\n  export struct Circle {}\n}\n\nlet x = new Shapes::Triangle;\n")),(0,o.kt)("p",null,"It is not recommended to export a single namespace from inside a module, as this leads to unnecessary typing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang",metastring:'title="src/shapes.cat"',title:'"src/shapes.cat"'},"export namespace Shapes {\n  export struct Triangle {}\n  export struct Circle {}\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang",metastring:'title="src/shapesConsumer.cat"',title:'"src/shapesConsumer.cat"'},'import * as shapes from "./shapes.cat"\nlet x = new shapes::Shapes::Triangle; // shapes::Shapes is unnecessary\n')),(0,o.kt)("h3",{id:"aliases"},"Aliases"),(0,o.kt)("p",null,"Namespaces and namespace exports can be aliased with the ",(0,o.kt)("inlineCode",{parentName:"p"},"using")," declaration."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-catlang"},"namespace Shapes {\n  export struct Triangle {}\n  export struct Circle {}\n}\n\nusing STriangle = Shapes::Triangle;\n")))}d.isMDXComponent=!0}}]);