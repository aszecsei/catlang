"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[906],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),g=i,m=d["".concat(s,".").concat(g)]||d[g]||u[g]||r;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9981:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={id:"casting",title:"Casting",sidebar_label:"Casting"},s=void 0,c={unversionedId:"casting",id:"casting",title:"Casting",description:"Casting is a way to check the type of an instance or to treat an instance of one type as another.",source:"@site/docs/casting.md",sourceDirName:".",slug:"/casting",permalink:"/catlang/docs/casting",draft:!1,editUrl:"https://github.com/aszecsei/catlang/edit/master/website/docs/casting.md",tags:[],version:"current",frontMatter:{id:"casting",title:"Casting",sidebar_label:"Casting"},sidebar:"docs",previous:{title:"Iterators",permalink:"/catlang/docs/iterators"},next:{title:"Generics",permalink:"/catlang/docs/generics"}},p={},u=[{value:"Type Checking",id:"type-checking",level:2},{value:"Safe Casting",id:"safe-casting",level:2},{value:"Unsafe Casting",id:"unsafe-casting",level:2},{value:"Type Coercion",id:"type-coercion",level:2},{value:"Stricter Qualification",id:"stricter-qualification",level:3},{value:"Integer and Float Widening",id:"integer-and-float-widening",level:3},{value:"Optionals",id:"optionals",level:3},{value:"Union Types",id:"union-types",level:3},{value:"Any",id:"any",level:3}],d={toc:u};function g(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Casting is a way to check the type of an instance or to treat an instance of one type as another."),(0,r.kt)("h2",{id:"type-checking"},"Type Checking"),(0,r.kt)("p",null,"Type checking is performed with the ",(0,r.kt)("inlineCode",{parentName:"p"},"is")," operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},'const x: int | string = otherFunction();\nif (x is int) {\n  print("x is an int!");\n} else {\n  print("x is a string!");\n}\n')),(0,r.kt)("h2",{id:"safe-casting"},"Safe Casting"),(0,r.kt)("p",null,"Safe casting checks if a casting operator exists between the two provided types. If not enough information exists to ensure that such a casting operator exists (for example, if the provided variable's type is a type union) then it will return an optional type, equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"type | null"),"; this safe cast must be evaluated at run-time. If run-time type information indicates that the variable's ",(0,r.kt)("em",{parentName:"p"},"actual value")," is of the casted type, the cast will succeed. Otherwise, the cast will return ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"However, if a cast operator exists between the two types, then the cast operator will be invoked and the resultant type will simply be the casted-to type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const x: int | string = otherFunction();\nconst myFunc = (i: int) -> {\n  // Something\n}\n\nmyFunc(x); // ERROR!\nmyFunc(x as int); // ERROR!\nlet castX = x as int;\nif (castX) {\n  myFunc(castX); // OK\n}\n")),(0,r.kt)("p",null,"Since an assignment operator returns the object that was assigned, the previous example can be condensed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"if (let castX = x as int) {\n  myFunc(castX); // OK\n}\n")),(0,r.kt)("p",null,"This has the twofold benefit of being more concise and scoping the ",(0,r.kt)("inlineCode",{parentName:"p"},"castX")," variable to the ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," block."),(0,r.kt)("p",null,"Internally, numbers can be safely cast to any number type that is guaranteed not to lose data. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const ch: char = 'a';\nconst xInt: int = ch as int; // OK!\nconst yInt: int = -2;\nconst yChar = yInt as char; // ERROR!\n")),(0,r.kt)("h2",{id:"unsafe-casting"},"Unsafe Casting"),(0,r.kt)("p",null,"Unsafe casting is used to force a cast from one value to another. While this can be used to avoid type lookups at run-time, it is not recommended for standard use. This is equivalent to a C-style cast."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const x: long = 5000000000;\nconst y = x as! int; // 705032704\n")),(0,r.kt)("h2",{id:"type-coercion"},"Type Coercion"),(0,r.kt)("p",null,"A limited amount of type coercion is permitted - namely, when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe."),(0,r.kt)("h3",{id:"stricter-qualification"},"Stricter Qualification"),(0,r.kt)("p",null,"Variables in catlang can be coerced to constant versions of those variables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let x: int = 32;\nconst y: int = x;\n")),(0,r.kt)("p",null,"Non-volatile variables can also be coerced to volatile variables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let x: int = 32;\nlet y: volatile int = x;\n")),(0,r.kt)("h3",{id:"integer-and-float-widening"},"Integer and Float Widening"),(0,r.kt)("p",null,"Ints can coerce to ints which can represent every value of the old type, and likewise floats coerce to floats which can represent any value of the old type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: u8 = 250;\nlet b: u16 = a;\nlet c: u32 = b;\nlet d: u64 = d;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: u8 = 250;\nlet b: i16 = a;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: float = 12.34;\nlet b: double = a;\n")),(0,r.kt)("h3",{id:"optionals"},"Optionals"),(0,r.kt)("p",null,"Non-optional types can be coerced to their optional equivalents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: int = 16;\nlet b: int? = a;\n")),(0,r.kt)("h3",{id:"union-types"},"Union Types"),(0,r.kt)("p",null,"Types can be coerced to any union type that contains the type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: int = 16;\nlet b: int | bool = a;\n")),(0,r.kt)("h3",{id:"any"},"Any"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," type can be coerced into any other type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let a: any = 16;\nlet b: int = a;\n")),(0,r.kt)("p",null,"This can be very dangerous, as there is no guarantee that re-interpreting an ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," value will not lead to undefined behavior."))}g.isMDXComponent=!0}}]);