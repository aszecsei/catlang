"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[460],{3905:(t,e,n)=>{n.d(e,{Zo:()=>s,kt:()=>k});var a=n(7294);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,l=function(t,e){if(null==t)return{};var n,a,l={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(l[n]=t[n]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(l[n]=t[n])}return l}var p=a.createContext({}),d=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},s=function(t){var e=d(t.components);return a.createElement(p.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,l=t.mdxType,r=t.originalType,p=t.parentName,s=o(t,["components","mdxType","originalType","parentName"]),u=d(n),k=l,c=u["".concat(p,".").concat(k)]||u[k]||m[k]||r;return n?a.createElement(c,i(i({ref:e},s),{},{components:n})):a.createElement(c,i({ref:e},s))}));function k(t,e){var n=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=n.length,i=new Array(r);i[0]=u;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o.mdxType="string"==typeof t?t:l,i[1]=o;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3532:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>p,default:()=>k,frontMatter:()=>o,metadata:()=>d,toc:()=>m});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={id:"types",title:"Types",sidebar_label:"Types"},p=void 0,d={unversionedId:"types",id:"types",title:"Types",description:"Catlang is statically-typed; every expression has a type.",source:"@site/docs/types.md",sourceDirName:".",slug:"/types",permalink:"/catlang/docs/types",draft:!1,editUrl:"https://github.com/aszecsei/catlang/edit/master/website/docs/types.md",tags:[],version:"current",frontMatter:{id:"types",title:"Types",sidebar_label:"Types"},sidebar:"docs",previous:{title:"Syntax",permalink:"/catlang/docs/syntax"},next:{title:"Arrays",permalink:"/catlang/docs/arrays"}},s={},m=[{value:"Basic Data Types",id:"basic-data-types",level:2},{value:"Integer Numbers",id:"integer-numbers",level:3},{value:"Booleans",id:"booleans",level:3},{value:"Floating-Point",id:"floating-point",level:3},{value:"Unvalued",id:"unvalued",level:3},{value:"Miscellaneous",id:"miscellaneous",level:3},{value:"Derived Data Types",id:"derived-data-types",level:2},{value:"Pointer",id:"pointer",level:3},{value:"Static Array",id:"static-array",level:3},{value:"Dynamic Array",id:"dynamic-array",level:3},{value:"Functions",id:"functions",level:3},{value:"User-Defined Types",id:"user-defined-types",level:2},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Integer Promotions",id:"integer-promotions",level:3},{value:"Usual Arithmetic Conversions",id:"usual-arithmetic-conversions",level:3},{value:"Aliased Types",id:"aliased-types",level:2},{value:"size_t",id:"size_t",level:3},{value:"ptrdiff_t",id:"ptrdiff_t",level:3},{value:"Strings",id:"strings",level:3},{value:"Type Modifiers",id:"type-modifiers",level:2},{value:"Const Types",id:"const-types",level:3},{value:"Volatile Types",id:"volatile-types",level:3},{value:"Type Definitions",id:"type-definitions",level:2},{value:"Any",id:"any",level:2},{value:"Optionals",id:"optionals",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Type Inference",id:"type-inference",level:2},{value:"Best Common Type",id:"best-common-type",level:3},{value:"Contextual Typing",id:"contextual-typing",level:3}],u={toc:m};function k(t){var e=t.components,n=(0,l.Z)(t,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Catlang is statically-typed; every expression has a type."),(0,r.kt)("h2",{id:"basic-data-types"},"Basic Data Types"),(0,r.kt)("h3",{id:"integer-numbers"},"Integer Numbers"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s8")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"signed 8 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u8")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 8 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s16")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"signed 16 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u16")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 16 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"signed 32 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u32")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 32 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s64")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"signed 64 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u64")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 64 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s128")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"signed 128 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u128")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 128 bits")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},"'xFF'"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned 8 bit (UTF-8 code unit)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"short")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"equivalent to ",(0,r.kt)("inlineCode",{parentName:"td"},"s16"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"equivalent to ",(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"long")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"equivalent to ",(0,r.kt)("inlineCode",{parentName:"td"},"s64"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_short")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_ushort")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_int")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_uint")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_long")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_ulong")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_longlong")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_ulonglong")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_longdouble")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Unless a type is specified, numbers are assumed to be the smallest type that can store the literal."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const a = 128; // u8\nconst b = 128.0; // f32\nconst c = 123.; // f32\nconst d: f64 = 128; // f64\nconst e = 128 as f32; // f32\n"))),(0,r.kt)("h3",{id:"booleans"},"Booleans"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean value")))),(0,r.kt)("h3",{id:"floating-point"},"Floating-Point"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"f32")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"32-bit floating point")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"f64")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"64-bit floating point")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"float")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"equivalent to ",(0,r.kt)("inlineCode",{parentName:"td"},"f32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"double")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"equivalent to ",(0,r.kt)("inlineCode",{parentName:"td"},"f64"))))),(0,r.kt)("h3",{id:"unvalued"},"Unvalued"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"null")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"null has no value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"c_void")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"for ABI compatibility with C")))),(0,r.kt)("h3",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Keyword"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"type")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"represents a type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"any")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"escape the type system")))),(0,r.kt)("h2",{id:"derived-data-types"},"Derived Data Types"),(0,r.kt)("h3",{id:"pointer"},"Pointer"),(0,r.kt)("p",null,"Pointer types are prefixed with a ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let i: *int = @myInt;\n")),(0,r.kt)("p",null,"Pointers cannot be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),". To use a null pointer, it must be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"*T?"),". The size of an optional pointer is guaranteed to be the same as the size of the pointer, and the value of the null pointer is guaranteed to be 0."),(0,r.kt)("p",null,"To retrieve the pointer to an object, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," operator. To dereference a pointer, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator."),(0,r.kt)("p",null,"Functions can be called on pointers the same way they can on standard objects - there's no need for C++'s arrow operator."),(0,r.kt)("h3",{id:"static-array"},"Static Array"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"arrays"},"Arrays"),"."),(0,r.kt)("h3",{id:"dynamic-array"},"Dynamic Array"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"arrays"},"Arrays"),"."),(0,r.kt)("h3",{id:"functions"},"Functions"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"functions"},"Functions"),"."),(0,r.kt)("h2",{id:"user-defined-types"},"User-Defined Types"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"enums"},"Enums")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"structs"},"Structs")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"unions"},"Unions")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"interfaces"},"Interfaces"))),(0,r.kt)("h2",{id:"type-conversions"},"Type Conversions"),(0,r.kt)("h3",{id:"integer-promotions"},"Integer Promotions"),(0,r.kt)("p",null,"Integer promotions are conversions of the following types:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"from"),(0,r.kt)("th",{parentName:"tr",align:null},"to"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s8")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u8")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s16")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u16")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s32"))))),(0,r.kt)("p",null,"If an enum has as a base type one of the types in the left column, it is converted to the type in the right column."),(0,r.kt)("h3",{id:"usual-arithmetic-conversions"},"Usual Arithmetic Conversions"),(0,r.kt)("p",null,"The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If either operand is ",(0,r.kt)("inlineCode",{parentName:"li"},"f64"),", the other operand is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"f64"),"."),(0,r.kt)("li",{parentName:"ol"},"Else if either operand is ",(0,r.kt)("inlineCode",{parentName:"li"},"f32"),", the other operand is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"f32"),"."),(0,r.kt)("li",{parentName:"ol"},"Else the integer promotions are done on each operand, followed by:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"If both are the same type, no more conversions are done."),(0,r.kt)("li",{parentName:"ol"},"If both are signed or both are unsigned, the smaller type is converted to the larger."),(0,r.kt)("li",{parentName:"ol"},"If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type."),(0,r.kt)("li",{parentName:"ol"},"The signed type is converted to the unsigned type.")))),(0,r.kt)("h2",{id:"aliased-types"},"Aliased Types"),(0,r.kt)("h3",{id:"size_t"},"size_t"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"size_t")," is an alias to one of the unsigned integral basic types, and represents a type that is large enough to represent an offset into all addressable memory."),(0,r.kt)("h3",{id:"ptrdiff_t"},"ptrdiff_t"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ptrdiff_t")," is an alias to the signed integral basic type the same size as ",(0,r.kt)("inlineCode",{parentName:"p"},"size_t"),"."),(0,r.kt)("h3",{id:"strings"},"Strings"),(0,r.kt)("p",null,"Catlang uses the C-style convention that character literals are wrapped with single quotes, while string literals are wrapped with double quotes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const a = 'a'; // char\nconst b = \"a\"; // string\nconst c = \"abc\"; // string\nconst d = 'abc'; // ERROR!\n")),(0,r.kt)("p",null,"A notable feature of the language is string interpolation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},'let name = "";\nprint("Enter your name: ");\nreadLine(name);\nprint("Hello, ${name}!\\n");\n')),(0,r.kt)("h2",{id:"type-modifiers"},"Type Modifiers"),(0,r.kt)("h3",{id:"const-types"},"Const Types"),(0,r.kt)("p",null,"Types can be marked as const to indicate that they are immutable. This attribute is applied to any ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," declarations; for example, in"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const x: int = 0;\n")),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"const int"),". This normally has no impact when passing ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," to functions, as pass-by-value copying means that the ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," attribute can be safely removed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"function timesTwo(a: int) -> int {\n  return a * 2;\n}\n\nconst x: int = 16;\nlet y = timesTwo(x);\n")),(0,r.kt)("p",null,"However, if a pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," were to be passed, that type would be ",(0,r.kt)("inlineCode",{parentName:"p"},"*const int"),", which would restrict modifications to ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"function timesTwo(a: *int) -> {\n  *a *= 2;\n}\n\nconst x: int = 16;\ntimesTwo(@x); // ERROR!\n")),(0,r.kt)("h3",{id:"volatile-types"},"Volatile Types"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"volatile")," type modifier indicates to the compiler that variables of this type may be modified by external sources, most commonly via memory-mapped I/O or multithreading."),(0,r.kt)("h2",{id:"type-definitions"},"Type Definitions"),(0,r.kt)("p",null,"Catlang allows users to write shorthands to refer to complex types. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"type number = s8 | u8 | s16 | u16 | s32 | u32 | s64 | u64 | f32 | f64;\nconst genericFunction = (input: number) -> {\n  return input * 2;\n}\n")),(0,r.kt)("h2",{id:"any"},"Any"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," type is the equivalent of C's ",(0,r.kt)("inlineCode",{parentName:"p"},"void*")," type. It can be used to escape Catlang's type system - ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," types can be cast to any type without any analysis. Note that this will ",(0,r.kt)("em",{parentName:"p"},"not")," perform any transformations on numeric types - a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," cast to ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," and then cast to ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," will be an integer representation of the bits of that float, which is unlikely to be the desired behavior of such a casting operation. Be very careful when using this feature!"),(0,r.kt)("h2",{id:"optionals"},"Optionals"),(0,r.kt)("p",null,'Catlang includes an "optional" type, equivalent to ',(0,r.kt)("inlineCode",{parentName:"p"},"type | null"),", to help avoid null-pointer exceptions. Any function that requires a non-Optional value must be enclosed in a conditional to ensure that the Optional value exists, or an error will be thrown."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},'const myPrint = (num: ?int) -> {\n  if (num) {\n    print(num);\n  } else {\n    print("Nope!");\n  }\n}\n')),(0,r.kt)("p",null,"If a user wishes to force-unwrap an optional value, they can use the null-forgiving (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") operation to do so. This is not recommended as it may lead to null-pointer exceptions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const myPrint = (num: ?int) -> {\n  print(num!);\n}\n")),(0,r.kt)("p",null,"To reduce if-statements, null-coalescing and null-conditional operators are provided."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"const myPrint = (obj: ?MyStruct) -> {\n   // This:\n  if (obj) {\n    obj.DoMethod();\n  }\n  // is equivalent to this using the null-conditional operator:\n  obj?.DoMethod();\n\n  // And this:\n  if (!obj) {\n    obj = defaultValue;\n  }\n  // is equivalent to this using the null coalescing assignment operator\n  obj ??= defaultValue;\n}\n")),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"TODO")),(0,r.kt)("h2",{id:"type-inference"},"Type Inference"),(0,r.kt)("p",null,"Catlang does its best to infer type information where appropriate. For example, in this code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let x = 3;\n")),(0,r.kt)("p",null,"The type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," variable is inferred to be ",(0,r.kt)("inlineCode",{parentName:"p"},"s32"),". This kind of inference takes place when initializing variables, creating arrays, and determining function return types."),(0,r.kt)("p",null,"In most cases, type inference is straightforward. In the following sections, we'll explore some of the nuances in how type inference occurs."),(0,r.kt)("h3",{id:"best-common-type"},"Best Common Type"),(0,r.kt)("p",null,'When multiple types are in use, Catlang attempts to find a "best common type" for those types. This usually creates the smallest type union possible to encompass all values used. For example, in this code'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"let x = [] { 1, 2, null };\n")),(0,r.kt)("p",null,"The type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," variable would be inferred to be ",(0,r.kt)("inlineCode",{parentName:"p"},"[](int | null)")," - or, equivalently, ",(0,r.kt)("inlineCode",{parentName:"p"},"[](?int)"),"."),(0,r.kt)("h3",{id:"contextual-typing"},"Contextual Typing"),(0,r.kt)("p",null,"In some cases, type inference can occur in the opposite direction - that is, the declared type influences the type of the expression. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-catlang"},"function floatMap(fun: (f32) -> float, arr: []f32) -> []f32 {\n  let res = new [arr.length]f32;\n  for (i = 0; i < arr.length; ++i) {\n    res[i] = fun(arr[i]);\n  }\n  return res;\n}\n\nfloatMap((f) -> {\n  return f * 2;\n}, [] { 2.4, 3 })\n")),(0,r.kt)("p",null,"Catlang is able to infer two things that it normally would not do: first, that the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," in the anonymous function argument is a ",(0,r.kt)("inlineCode",{parentName:"p"},"f32")," type, and second, that the value ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," in the array argument should be considered ",(0,r.kt)("inlineCode",{parentName:"p"},"f32")," type."),(0,r.kt)("p",null,"Without the contextual information provided, Catlang would throw an error regarding the lack of type information for the ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," argument, and would interpret the array as being of type ",(0,r.kt)("inlineCode",{parentName:"p"},"[](int | float)"),"."))}k.isMDXComponent=!0}}]);