\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{libertine} % Normal text
\usepackage[scaled=.8]{DejaVuSansMono} % Code

\usepackage{listings} % For code environments

\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}

% ========== DEFINE COLORS ==========
\definecolor{navy}{HTML}{001F3F}
\definecolor{blue}{HTML}{0074D9}
\definecolor{aqua}{HTML}{7FDBFF}
\definecolor{teal}{HTML}{39CCCC}
\definecolor{olive}{HTML}{3D9970}
\definecolor{green}{HTML}{2ECC40}
\definecolor{lime}{HTML}{01FF70}
\definecolor{yellow}{HTML}{FFDC00}
\definecolor{orange}{HTML}{FF851B}
\definecolor{red}{HTML}{FF4136}
\definecolor{maroon}{HTML}{85144B}
\definecolor{fuchsia}{HTML}{F012BE}
\definecolor{purple}{HTML}{B10DC9}
\definecolor{gray}{HTML}{AAAAAA}
\definecolor{silver}{HTML}{DDDDDD}

% ========== DEFINE LANGUAGE KEYWORDS ==========
\lstdefinelanguage{catlang}
{
	morekeywords = [1]{
		let,
		const,
		new,
		delete
		typeof,
		is,
		as,
		in,
		function,
		return,
		struct,
		type,
		enum,
		SOA,
		import,
		export,
		from
	},
	morekeywords = [2]{ % Control
		for,
		while,
		if,
		else,
	},
	morekeywords = [3]{ % Built-In Values
		true,
		false,
		null,
		any,
		S8,
		U8,
		S16,
		U16,
		S32,
		U32,
		S64,
		U64,
		char,
		int,
		long,
		bool,
		float,
		double,
		string,
		this,
		constructor,
	},
	keywordstyle = [1]\color{purple}\bfseries,
	keywordstyle = [2]\color{blue}\bfseries,
	keywordstyle = [3]\color{teal}\bfseries,
  	sensitive=true, % keywords are case-sensitive
  	morecomment=[l]{//}, % line comment
  	morecomment=[s]{/*}{*/}, % start and end delimeter
  	morestring=[b]",
  	morestring=[b]',
  	showstringspaces=false,
  	stringstyle=\color{red},
  	commentstyle=\color{gray}\itshape,
  	identifierstyle=\color{maroon},
}

\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{darkgray}\bfseries,
  ndkeywords={},
  ndkeywordstyle=\color{black}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  %moredelim=[l]{}{:},
  comment=[l]{\#\ },
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{blue}\ttfamily,
  %morestring=[l]{-}{},
  morestring=[b]',
  morestring=[b]"
}

\title{CatLang Design Doc}
\author{Alic Szecsei}

\begin{document}

\lstset{
	language=catlang,
	basicstyle=\ttfamily,
	breaklines=true,
}

\maketitle

\tableofcontents

\clearpage

\section{Background}

My goal with CatLang is to produce a programming language well-suited for low-level programming (such as game development) which includes many of the features common in more modern programming languages. I hardly propose that CatLang is a universal fix, but it seems like an engaging venture for my specific uses (and personal opinions about what a ``good programming language'' looks like).

A few notes about specific opinions I hold: \emph{kind} type-safety is important. Compilers should be able to infer as much as possible. Functions should be first-class; purely functional languages are too rigid, especially when performance is critical, but enabling programmers to use \emph{aspects} of functional languages seems the best of both worlds.

\section{Functions}

Functions can be defined in a C-like fashion:

\begin{lstlisting}
function timesTwo(num: int) -> int {
	return num * 2;
}
\end{lstlisting}

This is syntactically equivalent to a second, more functional approach:

\begin{lstlisting}
const timesTwo = (num: int) -> int {
	return num * 2;
}
\end{lstlisting}

\section{Typing}

CatLang uses strong typing, although some typing can be inferred. As an example:

\begin{lstlisting}
const timesTwo = (num) -> {
	return num * 2;
} // ERROR! Argument types cannot be inferred

const timesTwo = (num: int) -> {
	return num * 2;
} // OK!

const PI = 3.14159265; // OK!
\end{lstlisting}

\subsection{Type Unions}

Types can be composed through unions; this means that a value can be one of the listed types. For example:

\begin{lstlisting}
const falseIfEven = (num : int) -> {
	if (num % 2 == 0) {
		return false;
	}
	return num;
}
\end{lstlisting}

This method will return an object of type \lstinline!bool | int!; that is to say that it may be either a \lstinline!bool! or an \lstinline!int!, and CatLang cannot deterministically know which one it will be. Any further uses of the returned value must allow for \emph{both} possibilities, or CatLang will throw an error.

\section{Casting}

Casting is a way to check the type of an instance or to treat an instance of one type as another. There is no implicit casting in CatLang.

\subsection{Type Checking}

Type checking is performed with the \lstinline!is! operator:

\begin{lstlisting}
const x: int | string = otherFunction();
if (x is int) {
	print("This is an int!");
} else {
	print("This is a string!");
}
\end{lstlisting}

\subsection{Safe Casting}

Safe casting returns an optional type, equivalent to \lstinline!type | null!; safe casting must be evaluated at run-time. If run-time type information indicates that the variable's \emph{actual value} is of the casted type, the cast will succeed. Otherwise, the cast will return \lstinline!null!.

\begin{lstlisting}
const x: int | string = otherFunction();
const myFunc = (i: int) -> {
	// Something
}

myFunc(x); // ERROR!
myFunc(x as int); // ERROR!
if (let castX = x as int) {
	myFunc(castX); // OK
}
\end{lstlisting}

The reason this last example works is that an assignment operator returns the object that was assigned; the last if statement is thus equivalent to:

\begin{lstlisting}
let castX = x as int;
if (castX) {
	myFunc(castX);
}
\end{lstlisting}

Numbers can be safely cast to any number type that is guaranteed not to lose data. For example:

\begin{lstlisting}
const xChar = 'a'
const xInt = xChar as int // OK!
const yInt = -2
const yChar = yInt as char // ERROR!
\end{lstlisting}

\subsection{Unsafe Casting}

Unsafe casting is used to force a cast from one value to another. While this can be used to avoid type lookups at run-time, it is not recommended for standard use. This is equivalent to a C-style cast.

\begin{lstlisting}
const x: long = 5000000000;
const y = x as! int; // 705032704
\end{lstlisting}

\section{Native Types}

\subsection{Primitives}

\begin{enumerate}
	\item Integer Numbers
	\begin{enumerate}
		\item \lstinline!S8! (1 byte, signed)
		\item \lstinline!U8! (1 byte, unsigned)
		\item \lstinline!S16! (2 bytes, signed)
		\item \lstinline!U16! (2 bytes, unsigned)
		\item \lstinline!S32! (4 byte, signed)
		\item \lstinline!U32! (4 byte, unsigned)
		\item \lstinline!S64! (8 byte, signed)
		\item \lstinline!U64! (8 byte, unsigned)
		\item \lstinline!char! (equivalent to U8)
		\item \lstinline!int! (equivalent to S32)
		\item \lstinline!long! (equivalent to S64)
	\end{enumerate}
	\item Booleans
	\begin{enumerate}
		\item \lstinline!bool! (1 byte)
	\end{enumerate}
	\item Floating-Point Numbers
	\begin{enumerate}
		\item \lstinline!float! (4 bytes)
		\item \lstinline!double! (8 bytes)
	\end{enumerate}
	\item Unvalued
	\begin{enumerate}
		\item \lstinline!null!
	\end{enumerate}
\end{enumerate}

\subsubsection{Number Literals}

Unless a type is specified, numbers are assumed to be either a signed 4-byte integer (\lstinline!int!) if they do not include a decimal point or a 4-byte \lstinline!float! if they do.

\begin{lstlisting}
const a = 128; // automatically of type int
const b = 128.0 // automatically of type float
const c = 123. // also a float
const d: float = 128 // explicitly made a float
const e = 128 as float // explictly made a float 
\end{lstlisting}

\subsubsection{String Literals}

CatLang uses the C-style convention that character literals are wrapped with single quotes, while string literals are wrapped with double quotes:

\begin{lstlisting}
const a = 'a' // char
const b = "abc" // string
const c = "a" // string
const d = 'abc' // ERROR!
\end{lstlisting}

\subsection{Type Definitions}
CatLang allows users to write shorthands to refer to complex types. For example,

\begin{lstlisting}
type number = S8 | U8 | S16 | U16 | S32 | U32 | S64 | U64
const genericFunction = (input: number) -> {
	return input * 2
}
\end{lstlisting}

\subsection{Any}

The \lstinline!any! type is the direct equivalent to C's \lstinline!void*! type.

\subsection{Optionals}

CatLang uses an ``optional'' type, equivalent to \lstinline!type | null!, to help avoid null-pointer exceptions. Any function that requires a non-Optional value must be enclosed in a conditional to ensure that the Optional value exists, or an error will be thrown.

\begin{lstlisting}
const myPrint = (num?: int) -> {
	if (num) {
		print(num);
	} else {
		print("Nope!");
	}
} // OK!

const myPrint2 = (num?: int) -> {
	print(num);
} // ERROR!
\end{lstlisting}

If a user wishes to force-unwrap an optional value, they can use the \lstinline$!$ operation to do so. This is, however, not recommended and may lead to null-pointer exceptions.

\begin{lstlisting}
const myPrint = (num?: int) -> {
	print(num!);
} // OK!
\end{lstlisting}

\subsection{Collections}

CatLang has two ways to combine data: arrays and structs.

\subsubsection{Arrays}

CatLang's arrays differ from C-style arrays in that they contain information about their length.

\begin{lstlisting}
const finalElement = myArray[myArray.length - 1];
\end{lstlisting}

Arrays also include convenience methods for a more functional style of programming; namely, \lstinline!map!, \lstinline!filter!, \lstinline!each!, and \lstinline!reduce!. They are instantiated using a syntax similar to C:

\begin{lstlisting}
const arr = [25]int;
\end{lstlisting}

Arrays can be either static- or dynamically-sized:

\begin{lstlisting}
const staticArray  = [25]int;
const dynamicArray = [..]int;
\end{lstlisting}

Arrays of pointers and pointers to arrays are syntactically different:

\begin{lstlisting}
const pointerToArray  : *[]int = @myArray;
const arrayOfPointers : []*int = myArray;
\end{lstlisting}

Arrays can be iterated over:

\begin{lstlisting}
const arr = []int { 1, 2, 3, 4, 5 };
for (x in arr) {
	print(x);
}
delete arr;
\end{lstlisting}

They can also iterate over inner properties of structs; in the following example, loops A and B are equivalent:

\begin{lstlisting}
struct Vector3 {
	x : float;
	y : float;
	z : float;
}
const arr = []Vector3 { ... };
for (xVal in arr.x) {
	print(xVal);
} // A
for (vec in arr) {
	print(vec.x);
} // B
\end{lstlisting}

\subsubsection{Strings}

CatLang's \lstinline!string! type is a wrapper around \lstinline!Array<char>!. A notable feature of the language is string interpolation:

\begin{lstlisting}
let name = "";
print("Enter your name: ");
readLine(name);
print("Hello, ${name}!\n");
\end{lstlisting}

\subsubsection{Structs}

CatLang's syntax for defining structures is straightforward:

\begin{lstlisting}
struct Vector3 {
	x : float;
	y : float;
	z : float;
}
\end{lstlisting}

Structs can also have default values assigned:

\begin{lstlisting}
struct Vector3 {
	x : float = 1.0;
	y : float = 2.0;
	z : float = 3.0;
}
\end{lstlisting}

To denote an ``owned'' property in a struct, use the \lstinline$!$ keyword. When a struct is deleted, all owned properties are also deleted.

\begin{lstlisting}
struct Transform {
	position : ! Vector3;
	rotation : ! Quaternion;
}
\end{lstlisting}

To allocate memory on the stack, users should declare variables \emph{without} the \lstinline!new! keyword. If the \lstinline!new! keyword is used, the variable is allocated on the heap and must be freed later with the \lstinline!delete! keyword.

\begin{lstlisting}
const v1 = Vector3; // Allocated on the stack.
const v2 = new Vector3; // Allocated on the heap...
delete v2; // ...so must be manually freed.
\end{lstlisting}

Structs can define how they are stored in arrays, in order to reduce cache misses. Structs default to the ``array of structs'' schema, but can be swapped to the ``struct of arrays'' schema using the \lstinline!SOA! keyword:

\begin{lstlisting}
struct V3A {
	x : float = 1;
	y : float = 2;
	z : float = 3;
}
let v1 = [4]V3A; // Memory will contain 1 2 3 1 2 3 1 2 3 1 2 3

struct V3B SOA {
	x : float = 1;
	y : float = 2;
	z : float = 3;
}
let v2 = [4]V3B; // Memory will contain 1 1 1 1 2 2 2 2 3 3 3 3
\end{lstlisting}

No matter how these arrays are stored in memory, they are used and referenced the same way within CatLang code.

Fields of a struct that begin with an underscore are private fields and are only accessible to functions within the struct's namespace. All other fields are public.

\begin{lstlisting}
struct MyStruct {
	_hiddenVar : string;
	publicVar : string;
}
\end{lstlisting}

\subsection{Functions}

Global functions are defined without any namespace.

\begin{lstlisting}
const timesTwo = (num: int) -> {
	return num * 2;
}
const value = timesTwo(4);
\end{lstlisting}

Static functions are attached to a struct, but not an instance of that struct. They \emph{cannot} use the keyword \lstinline!this! in their parameter list.

\begin{lstlisting}
Vector3::dot = (first: Vector3, other: Vector3) -> {
	return first.x * second.x + first.y * second.y + first.z * second.z;
}
const v1 = Vector3;
const v2 = Vector3;
const dot = Vector3::dot(v1, v2);
\end{lstlisting}

Instance functions are attached to an instance of a struct. They \emph{must} include the keyword \lstinline!this! as the first parameter.

\begin{lstlisting}
Vector3::toString = (this) -> {
	return "(${this.x}, ${this.y}, ${this.z})";
}
const v1 = Vector3;
print(v1.toString());
\end{lstlisting}

There is one special instance function: if the \lstinline!constructor! function is declared, it is called whenever a new instance of the struct is created. If a constructor is declared, it \emph{must} be called; using the default constructor-less instantiation will raise an error.

\begin{lstlisting}
Vector3::constructor = (this, x: float, y: float, z: float) -> {
	this.x = x;
	this.y = y;
	this.z = z;
}
const v1 = Vector3(2, 3, 4); // OK
const v2 = new Vector3(1, 4, 9); // OK
const v3 = Vector3; // ERROR!
\end{lstlisting}

Functions attached to a struct, whether static or instance, are treated as immutable and cannot be redefined. The only way to overload a function is through the use of optional types.

Generic functions look similar to generics in other languages:

\begin{lstlisting}
const contains = <T>(arr: []T, value: T) -> {
	for (x in arr) {
		if (x == value) {
			return true;
		}
	}
	return false;
}
\end{lstlisting}

When generic functions are called, if the generic type can be inferred, it can be dropped:

\begin{lstlisting}
const arr = []int { 1, 2, 3, 4, 5 };
const result = contains(arr, 4);
\end{lstlisting}

However, if the generic type cannot be inferred, it must be made explicit:

\begin{lstlisting}
const arrayFactory = <T>(count: number) -> {
	return new [count]T;
}
const arr = arrayFactory(10); // ERROR!
const arr = arrayFactory<int>(10); // OK!
\end{lstlisting}

Functions can also be passed in to other functions, for a more functional style of programming. An example \lstinline!map! function might look like:

\begin{lstlisting}
const map = <InT, OutT>(arr: []T, fn: (InT)->OutT) -> {
	result = new [arr.count]OutT;
	for (x = 0; x < arr.count; x++) {
		result[x] = fn(arr[x]);
	}
	return result;
}
\end{lstlisting}

\subsection{Pointers}

Pointers can be retrieved from any struct or primitive. Optionals do not have pointers, although you can have an optional pointer. Functions can be called on pointers using the standard dot syntax, unlike C++'s arrow operator.

To retrieve the pointer to an object, use the \lstinline!@! operator. To retrieve an object from a pointer, use the \lstinline!*! operator.

\begin{lstlisting}
const myFunc = (x: *Vector3) -> {
	// This takes a pointer to a Vector3 struct
	print(x.toString()); // prints x as normal
}

const v = Vector3;
myFunc(@v);
\end{lstlisting}

Ownership works similarly with pointers:

\begin{lstlisting}
struct Transform {
	position : !*Vector3;
	rotation : !*Quaternion;
}
\end{lstlisting}

\subsection{Enums}

Enum types are declared similarly to structs:

\begin{lstlisting}
enum Alignment {
	Left, // 0
	Right, // 1
	Center, // 2
}
const a = Alignment::Left;
const val = a as U16;
\end{lstlisting}

By default, enums are wrappers around \lstinline!U16! values, starting at 0. However, they can be manually associated with other values:

\begin{lstlisting}
enum Alignment: U32 {
	Left, // 0
	Right = 12, // 12
	Center // 13
}
\end{lstlisting}

If the type an enum wraps is not able to be incremented (for example, a string) then the associated values of all enum values must be declared.

\section{Multi-File Programs}
CatLang, by default, does not export anything from a file for use in another file. However, using the \lstinline!export! keyword before a declaration makes it so that other files are allowed to \lstinline!import! declarations for later use.

For example:

\begin{lstlisting}
// foo.cat
export const x = 12

// bar.cat
import x from "foo"

const fun = () -> {
	print(x)
}
\end{lstlisting}

Directories can be used to create namespaces:

\begin{lstlisting}
// module/foo.cat
export const fun = () -> {
	print("Function!")
}

// bar.cat
import fun from "module/foo"

const main() -> {
	fun()
}
\end{lstlisting}

Imported declarations can be renamed:

\begin{lstlisting}
import fun as myFun from "module/foo"

const main() -> {
	myFun()
}
\end{lstlisting}

In addition to importing specific declarations, files can import entire files:

\begin{lstlisting}
import * as foo from "module/foo"

const main() -> {
	foo.fun()
}
\end{lstlisting}

\section{Build System}

\lstset{
	language=yaml,
	basicstyle=\ttfamily,
	breaklines=true,
}

CatLang is designed to scale well from small files to large projects. The CLI can be used to build a single file; CatLang will attempt to locate all files imported by that entry point, and so on, until all required files have been read.

For more complex projects, a configuration file is required, which must be named `package.yaml'.
\subsection{Configuration Fields}
\subsubsection{name}
The name of the project. This, together with the version form an identifier which is assumed to be completely unique. This name is what other users will refer to when they import your package. To ensure uniqueness, it is recommended that names be prefaced with a username - for example, \texttt{@aszecsei/my-package}.

A few rules:
\begin{itemize}
	\item The name may only consist of letters \texttt{a-z}, capital and lowercase; digits; the @ symbol; dashes; and underscores
	\item The name cannot start with an underscore or dash
	\item The name must be less than or equal to 256 characters.
\end{itemize}

\subsubsection{version}
The version numbers are assumed to follow the Semantic Versioning Specification, as described at \url{https://semver.org}.

\subsubsection{description}
A brief description of your project.

\subsubsection{keywords}
An optional list of keywords describing your project.

\subsubsection{homepage}
The URL to the project homepage.

Example:

\begin{lstlisting}
homepage: https://github.com/owner/project#readme
\end{lstlisting}

\subsubsection{bugs}
The URL to your project's issue tracker and/or the email address to which issues should be reported. These are helpful for people who encounter issues with your project.

\begin{lstlisting}
bugs:
	url: https://github.com/owner/project/issues
	email: project@hostname.com
\end{lstlisting}

If you only want to provide a URL, you can specify the value for ``bugs'' as a simple string instead of an object.

\subsubsection{license}
The license field should be either an SPDX license ID, or expression. If you are using a custom license, or a license which does not have an SPDX identifier, use a string value such as \texttt{SEE LICENSE IN <filename>}. Then include a file named \texttt{<filename>} at the top level of the project.

If you do not wish to grant others the right to use a private or unpublished project under any terms, set this value to \texttt{UNLICENSED}.

You can view the list of current SPDX licenses at \url{https://spdx.org/licenses/}.

\subsubsection{authors}
This is a list of people; a ``person'' object contains a required ``name'' field and optional ``url'' and ``email'' fields. As an alternative to a person object, you can use a single string in the format ``\texttt{John Doe <j@doe.com> (http://jdoe.com)}''.

\subsubsection{files}
This describes which files should be used by other projects depending on this project; the reverse of a \texttt{.gitignore} file. Omitting this field will make it default to \texttt{[``*'']}, which will include all files.

\subsubsection{main}
The filename of the entry-point of the program. For applications, this should be a file which contains the function \texttt{main}. For libraries, this might be a file which simply exports relevant functions for users of the library.

\subsubsection{repository}
This is where your project lives. This is important, as it is how the CatLang package manager downloads your code. A few valid repository listings:

\begin{lstlisting}
repository: github:user/repo
repository: gist:11081aaa281
repository: bitbucker:user/repo
repository: gitlab:user/repo
repository:
	type: git
	url: https://github.com/user/repo.git
\end{lstlisting}

\subsubsection{dependencies}
This is a map of package names to version ranges. Version ranges are strings which have one or more space-separated descriptors. Dependencies can also be identified with a git URL.

\begin{itemize}
	\item \texttt{\textbf{version}} Must match \texttt{version} exactly
	\item \texttt{\textbf{>version}} Must be greater than \texttt{version}
	\item \texttt{\textbf{>=version}} etc
	\item \texttt{\textbf{<version}}
	\item \texttt{\textbf{<=version}}
	\item \texttt{\textbf{\textasciitilde version}} Approximately equal to \texttt{version}
	\item \texttt{\textbf{\textasciicircum version}} Compatible with \texttt{version}
	\item \texttt{\textbf{1.2.x}} 1.2.0, 1.2.1, etc., but not 1.3.0
	\item \texttt{\textbf{*}} Matches any version
	\item \texttt{\textbf{github:user/repo}} Uses the master branch of the repo
\end{itemize}

\subsubsection{private}
Whether or not this project should show up in CatLang project searches. Defaults to \texttt{false}.

\subsection{Example Configuration File}

\begin{lstlisting}
name: @aszecsei/my-library
version: 0.1.0
description: A basic library to do some basic things.
keywords:
  - catlang
  - example
homepage: https://github.com/aszecsei/catlang#readme
bugs:
  url: https://github.com/aszecsei/catlang/issues
  email: aszecsei@gmail.com
license: MIT
authors:
  - name: Alic Szecsei
    email: aszecsei@gmail.com
    url: https://alic-szecsei.com
files:
  - src/**/*.cat
  - test/**/*.cat
main: src/main.cat
repository: github:aszecsei/catlang
dependencies:
  @guyfieri/project: ^2.3.1
  other: github:username/other
  yaml: 3.3.x
private: false
\end{lstlisting}

\subsection{Project Initialization}

A basic project configuration file can be created using the command \texttt{catlang init}. Alternately, passing an argument (\texttt{catlang init <name>}) will create a new folder \texttt{<name>} in the current directory and create a project configuration file within that new folder.

\end{document}